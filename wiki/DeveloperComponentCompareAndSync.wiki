#summary Developer's Guide - Component - CompareAndSync
#labels Phase-Implementation
#sidebar DeveloperGuideSidebar

= Overview =
The *!CompareAndSync* component in *Syncless* is the part of the system that handles the comparison and syncing of files and folders. From a logical point of view, it can be briefly split into 2 subcomponents; the manual subcomponent that handles all manual operations, and the seamless subcomponent that handles all the automated synchronization requests from another component, the *Monitor*.

Both sub-components are implemented very differently, as manual synchronization and automated synchronization are largely different. The manual subcomponent is implemented using a *Tree* in conjunction with the *Visitor Pattern*, while the seamless subcomponent is implemented using a *Queue*.


= Class Diagram =



= Description of Design =
== Data Transfer Objects and Entities ==
Before going in depth into the design, we will first take a look at the data transfer objects (DTO) and entities used throughout !CompareAndSync.


=== Request ===
Requests are data transfer objects sent to !CompareAndSync when a comparison or synchronization action is to be done. The *Request* object is an abstract class, from which all other requests will extend from. *!AutoSyncRequest* and *!ManualRequest* are the respective requests for seamless and manual mode. *!ManualRequest* is further extended to *!ManualSyncRequest* and *!ManualCompareRequest*.


=== !CompareObject ===
!CompareObjects are entities which are used during comparison and synchronization. There are basically 2 main kinds of !CompareObjects, the *!FileCompareObject* and the *!FolderCompareObject*. *!RootCompareObject* is a specific kind of !FolderCompareObject used to represent the root paths to be compared. There is also the *XMLCompareObject* which is used to store the file metadata and then used to populate the main !CompareObjects.


= Main Components =
We will now take a look at the main components of !CompareAndSync, which can be broadly divided to the controller layer, the manual component and the seamless component.


== Controller ==
*!CompareAndSyncController* is a facade for the other layers to interact with, hiding the underlying implementations and exposing only the necessary methods for syncing.


== Manual Components ==
As stated in the overview, the manual portion of the !CompareAndSync component is done using the Tree Visitor Pattern. Although the Tree Visitor Pattern is considered a bad design pattern in some cases, the usage of this pattern in our implementation of !CompareAndSync greatly enhances extensibility, as you will see later.

The classes of concern to us are:

  * !CompareObjectHelper
  * !BuilderVisitor
  * !ComparerVisitor
  * !FolderRenameVisitor
  * IVisitor
  * !SyncerVisitor
  * XMLMetadataVisitor
  * XMLWriterVisitor

*!CompareObjectHelper* is the class that contains the various traversal methods, namely, pre-traversal, post-traversal, and level-order traversal for traversing the tree. All the Visitor classes implement IVisitor interface. The general course of actions that occur for each synchronization are as follows:

  # *!BuilderVisitor* takes in a !RootCompareObject, and builds the directory trees for it under the given root paths.
  # *XMLMetadataVisitor* will then visit this built tree, and populate it with metadata about each file, if the file exists.
  # *!FolderRenameVisitor* is a very specific class that will then check for folder renames.
  # Next, *!ComparerVisitor* visits the tree and updates the state of each !CompareObject based on certain attributes like the last time the file was modified.
  # *!SyncerVisitor* will now traverse the tree and carry out the necessary actions based on the states updated by !ComparerVisitor, as well as update the final state of each folder and file.
  # Finally, *XMLWriterVisitor* will traverse the tree, and write the updated information of each folder and file to XML.

Also, all the Visitors use pre-traversal, since it makes sense to build, populate and synchronize the !CompareObjects from top-down. However, !ComparerVisitor uses post-traversal because it is necessary to update the state of each folder if a file under it has changed. Assuming a user wants to compare and analyze the results, but not do any actual synchronization, we simply remove !SyncerVisitor and XMLWriterVisitor from the sequence. It is also important to note that the Tree Visitor Pattern allows for very good modularity, and we can simply add on extra visitors to perform other tasks if necessary. Similarly, we can remove any visitors (except for !BuilderVisitor, because it is required to build the tree), if necessary. A good example would be to remove !FolderRenameVisitor if the developer does not want to handle folder renames.


== Seamless Components ==
!CompareAndSync is made such that the seamless component is completely separated from the manual component. There are various design and implementation issues for this, with one of them being that the seamless component is largely depending on receiving information from other objects. Moreover, in seamless mode, the file to sync is already know, with little to no need of doing a comparison. As such, there is no need to do the tedious job of building a tree.

The classes of concern to us for the seamless portion are as follows:

  * !SeamlessQueueControl
  * !SeamlessSyncer
  * XMLHelper

*!SeamlessQueueControl* is a class that contains a single queue to ensure the requests are handled in order, so as to prevent any possible conflicts. *!SeamlessSyncer* contains the necessary methods to handle seamless file synchronization, and upon each successful synchronization, *XMLHelper* will be called to update the metadata stored in side.


= Explanation of Algorithms =
The main algorithm we are going to discuss here is the manual component comparison. Yes, Syncless' main aim is seamless synchronization, but the manual synchronization is in fact activated every time a user launches the application, or connects a removable storage drive to it. In a way, it is "seamless" too. Thus, it is as important as the seamless component.

Using pre-traversal, !BuilderVisitor will build a tree based on the given root paths. However, instead of a node for each and every folder, it groups files and folders of the same name at each level into single node. For example, if we want to synchronize "Lectures", "Notes" and "School", and the content of the folders are as follows:

*Lectures*
  * SWEN.pdf
  * Extra Notes
    * Principles of Software Engineering.pdf

*Notes*
  * !BizComm.ppt

*School*
  * Extra Notes
    * Principles of Software Engineering.pdf

From the above, we can see that "SWEN.pdf" exists only in Lectures, "!BizComm.ppt" only in Notes, and "Extra Notes" folder exists in both Lectures and School. With the above, we will generate the following tree:

http://big5sync.googlecode.com/files/DeveloperCompareAndSyncDiagTreeSmall.png

With the above tree, it is very easy to compare as we only need to concern ourselves with a single node for every file. Now that the tree is built and populated with files, the XMLMetadataVisitor will populate each node with metadata, as well as create nodes if the file exists in the metadata but not in the folder. The metadata is very important in detecting if a file or folder has been renamed or deleted, so that the changes will be propagated across.

The !FolderRenameVisitor will now visit the tree, and detect for folder renames. The reason why it has to occur before any file comparison can take place is due to the fact that the algorithm attempts to merge any renamed folder with folders that have the old name, so that files can still be compared. There are two main methods in !FolderRenameVisitor, namely {{{!DetectFolderRename}}} and  {{{!MergeRenamedFolder}}}, that handles this. The code for {{{!DetectFolderRename}}} is as follows.

{{{
        private void DetectFolderRename(FolderCompareObject folder, string[] currentPaths)
        {
            //Count the number of items which are marked as delete inside this FolderCompareObject
            List<int> deletePos = new List<int>();
            for (int i = 0; i < currentPaths.Length; i++)
            {
                if (folder.ChangeType[i] == MetaChangeType.Delete)
                    deletePos.Add(i);
            }

            //If the number of items are not exactly 1, exit current method
            if (deletePos.Count != 1)
            {
                //If the number of items are more than one, mark each of their ChangeType to null, 
                //so that changes will propagate back to it
                foreach (int i in deletePos)
                    folder.ChangeType[i] = null;
                return;
            }

            FolderCompareObject f = null;

            for (int i = 0; i < currentPaths.Length; i++)
            {
                if (folder.ChangeType[i] == MetaChangeType.Delete)
                {
                    //Find the possible renamed folder based on metadata
                    f = folder.Parent.GetRenamedFolder(folder.Name, folder.CreationTime[i], i);

                    if (f != null)
                    {
                        int counter = 0;

                        for (int j = 0; j < f.ChangeType.Length; j++)
                        {
                            //Count the number of items marked as New, should have exactly one
                            if (f.ChangeType[j].HasValue && f.ChangeType[j] == MetaChangeType.New)
                                counter++;
                        }

                        //If number of items marked is not exactly one, mark the ChangeType as null,
                        //so that changes will propagate over, and exit the method
                        if (counter != 1)
                        {
                            folder.ChangeType[i] = null;                         
                            return;
                        }

                        //Merge renamed folder with deleted folder
                        MergeRenamedFolder(folder, f, i);
                    }
                }
            }
        }
}}}

After !FolderRenameVisitor is done with its job, !ComparerVisitor, the only visitor to use post-traversal instead of pre-traversal, will visit the tree. There are various methods in !ComparerVisitor that handles the detection of renamed files, as well as the comparing of files and folders. Let us take a look at the main function, `!CompareFiles`.

{{{
        private void CompareFiles(FileCompareObject file, string[] currentPaths)
        {
            //Some code for handling deleted and renamed files commented out
            
            //Keeps track of the index of the most updated file position
            int mostUpdatedPos = 0;

            //Set the most updated file position to the first file that exists
            for (int i = 0; i < currentPaths.Length; i++)
            {
                if (file.Exists[i])
                {
                    mostUpdatedPos = i;
                    break;
                }
            }

            //Set the priority of the file with the most update position to 1.
            file.Priority[mostUpdatedPos] = 1;


            for (int i = mostUpdatedPos + 1; i < currentPaths.Length; i++)
            {
                //Set all non-existent files to priority -1
                if (!file.Exists[i])
                {
                    file.Priority[i] = -1;
                    continue;
                }

                 //If the length or hash of the file at the most updated position is different from the current index,
                //a change has occurred
                if (file.Length[mostUpdatedPos] != file.Length[i] || file.Hash[mostUpdatedPos] != file.Hash[i])
                {
                    //Update the value of most updated position if the file at index i is more updated
                    if (file.LastWriteTime[i] > file.LastWriteTime[mostUpdatedPos])
                    {
                        file.Priority[i] = file.Priority[mostUpdatedPos] + 1;
                        mostUpdatedPos = i;
                    }
                }
                else
                {   //Set the priority of index i to be same as that of the most updated position if there is no change
                    file.Priority[i] = file.Priority[mostUpdatedPos];
                }
            }

            for (int i = 0; i < currentPaths.Length; i++)
            {
                //Set parent folder to be dirty if the file has a lower priority than the one with the most updated position
                if (file.Exists[i] && file.Priority[i] != file.Priority[mostUpdatedPos])
                {
                    file.Parent.Dirty = true;
                    break;
                }
            }
        }
}}}


To summarize, !ComparerVisitor simply assigns a priority of 1 to the first file that it determines exist. Subsequently, it will iterate through, and files which are less updated than it will be untouched (thus, 0, since that is the default int value), and when it comes across a file which is more updated, the most updated position will be set to this file, with the priority incremented by one. Files which are determined to be equal to the one with the most updated position will be given the same priority. In other words, if all files in the given !FileCompareObject are equal, then all files will have priority 1. Let us further illustrate with the following example, using just the time of the day to represent how updated the file is:

|| A\Note.txt (10PM) || B\Note.txt (10PM) || C\Note.txt (9PM) || D\Note.txt (11PM) || E\Note.txt (8AM) ||

After applying the above algorithm, we should get the following, with the priorities in brackets now.

|| A\Note.txt (1) || B\Note.txt (1) || C\Note.txt (0) || D\Note.txt (2) || E\Note.txt(0) ||

Clearly, D\Note.txt is the most updated file. To end it off, !SyncerVisitor will then look for the file or folder with the highest priority at each node, and execute the necessary action base on the !ChangeType. Once that is done, XMLWriterVisitor will visit it and write the updated values, such as the hash and last modified date, back to the metadata.


= Extending !CompareAndSync =
Further functionality can be added into !CompareAndSync should a developer wish to. He can simply create his own visitor that visits each node and performs the action he decides. A good example would be to generate a report after a synchronization. A developer can simply code a visitor to create a report based on the attributes of each node.