#summary Developer's Guide - Component - CompareAndSync
#labels Phase-Implementation

= CompareAndSync=

== Overview ==
The *CompareAndSync* component in *Syncless* is the part of the system that handles the comparison and syncing of files and folders. From a logical point of view, it can be briefly split into 2 subcomponents; the manual subcomponent that handles all manual operations, and the seamless subcomponent that handles all the automated synchronization requests from another component, the *Monitor*.

Both sub-components are implemented very differently, as manual synchronization and automated synchronization are largely different. The manual subcomponent is implemented using a *Tree* in conjunction with the *Visitor Pattern*, while the seamless subcomponent is implemented using a *Queue*.


== Class Diagram ==



== Description of Design ==
=== Data Transfer Objects and Entities ===
Before going in depth into the design, we will first take a look at the data transfer objects (DTO) and entities used throughout CompareAndSync.


==== Request ====
Requests are data transfer objects sent to CompareAndSync when a comparison or synchronization action is to be done. The Request object is an abstract class, from which all other requests will extend from. AutoSyncRequest and ManualRequest are the respective requests for seamless and manual mode. ManualRequest is further extended to ManualSyncRequest and ManualCompareRequest.


==== CompareObject ====
CompareObjects are entities which are used during comparison and synchronization. There are basically 2 main kinds of CompareObjects, the FileCompareObject and the FolderCompareObject. RootCompareObject is a specific kind of FolderCompareObject used to represent the root paths to be compared. There is also the XMLCompareObject which is used to store the file metadata and then used to populate the main CompareObjects.


== Main Components ==
We will now take a look at the main components of CompareAndSync, which can be broadly divided to the controller layer, the manual component and the seamless component.


=== Controller ===
*CompareAndSyncController* is a facade for the other layers to interact with, hiding the underlying implementations and exposing only the necessary methods for syncing.


=== Manual Components ===
As stated in the overview, the manual portion of the CompareAndSync component is done using the Tree Visitor Pattern. Although the Tree Visitor Pattern is considered a bad design pattern in some cases, the usage of this pattern in our implementation of CompareAndSync greatly enhances extensibility, as you will see later.

The classes of concern to us are:

  * CompareObjectHelper
  * BuilderVisitor
  * ComparerVisitor
  * FolderRenameVisitor
  * IVisitor
  * SyncerVisitor
  * XMLMetadataVisitor
  * XMLWriterVisitor

CompareObjectHelper is the class that contains the various traversal methods, namely, pre-traversal, post-traversal, and level-order traversal for traversing the tree. All the Visitor classes implement IVisitor interface. The general course of actions that occur for each synchronization are as follows:

  # BuilderVisitor takes in a RootCompareObject, and builds the directory trees for it under the given root paths.
  # XMLMetadataVisitor will then visit this built tree, and populate it with metadata about each file, if the file exists.
  # FolderRenameVisitor is a very specific class that will then check for folder renames.
  # Next, ComparerVisitor visits the tree and updates the state of each CompareObject based on certain attributes like the last time the file was modified.
  # SyncerVisitor will now traverse the tree and carry out the necessary actions based on the states updated by ComparerVisitor, as well as update the final state of each folder and file.
  # Finally, XMLWriterVisitor will traverse the tree, and write the updated information of each folder and file to XML.

Also, all the Visitors use pre-traversal, since it makes sense to build, populate and synchronize the CompareObjects from top-down. However, ComparerVisitor uses post-traversal because it is necessary to update the state of each folder if a file under it has changed. Assuming a user wants to compare and analyze the results, but not do any actual synchronization, we simply remove SyncerVisitor and XMLWriterVisitor from the sequence. It is also important to note that the Tree Visitor Pattern allows for very good modularity, and we can simply add on extra visitors to perform other tasks if necessary. Similarly, we can remove any visitors (except for BuilderVisitor, because it is required to build the tree), if necessary. A good example would be to remove FolderRenameVisitor if the developer does not want to handle folder renames.


=== Seamless Components ===
CompareAndSync is made such that the seamless component is completely separated from the manual component. There are various design and implementation issues for this, with one of them being that the seamless component is largely depending on receiving information from other objects. Moreover, in seamless mode, the file to sync is already know, with little to no need of doing a comparison. As such, there is no need to do the tedious job of building a tree.

The classes of concern to us for the seamless portion are as follows:

  * SeamlessQueueControl
  * SeamlessSyncer
  * XMLHelper

SeamlessQueueControl is a class that contains a single queue to ensure the requests are handled in order, so as to prevent any possible conflicts. SeamlessSyncer contains the necessary methods to handle seamless file synchronization, and upon each successful synchronization, XMLHelper will be called to update the metadata stored in side.


== Explanation of Algorithms ==
The main algorithm we are going to discuss here is the manual component comparison. Yes, Syncless' main aim is seamless synchronization, but the manual synchronization is in fact activated every time a user launches the application, or connects a removable storage drive to it. In a way, it is "seamless" too. Thus, it is as important as the seamless component.

Using pre-traversal, BuilderVisitor will build a tree based on the given root paths. However, instead of a node for each and every folder, it groups files and folders of the same name at each level into single node. For example, if we want to synchronize "Lectures", "Notes" and "School", and the content of the folders are as follows:

*Lectures*
-SWEN.pdf
-Extra Notes
 -Principles of Software Engineering.pdf

*Notes*
-BizComm.ppt

*School*
-Extra Notes
 -Principles of Software Engineering.pdf

From the above, we can see that "SWEN.pdf" exists only in Lectures, "BizComm.ppt" only in Notes, and "Extra Notes" folder exists in both Lectures and School. With the above, we will generate the following tree:

http://big5sync.googlecode.com/files/DeveloperCompareAndSyncDiagTreeSmall.png

With the above tree, it is very easy to compare as we only need to concern ourselves with a single node for every file. Now that the tree is built and populated with files, the XMLMetadataVisitor will populate each node with metadata, as well as create nodes if the file exists in the metadata but not in the folder. The metadata is very important in detecting if a file or folder has been renamed or deleted, so that the changes will be propagated across.

The FolderRenameVisitor will now visit the tree, and detect for folder renames. The reason why it has to occur before any file comparison can take place is due to the fact that the algorithm attempts to merge any renamed folder with folders that have the old name, so that files can still be compared. There are two main methods in FolderRenameVisitor, namely _DetectFolderRename_ and  _MergeRenamedFolder_, that handles this. The code for _DetectFolderRename_ is as follows.

{{{
        private void DetectFolderRename(FolderCompareObject folder, string[] currentPaths)
        {
            List<int> deletePos = new List<int>();
            for (int i = 0; i < currentPaths.Length; i++)
            {
                if (folder.ChangeType[i] == MetaChangeType.Delete)
                    deletePos.Add(i);
            }

            if (deletePos.Count != 1)
            {
                foreach (int i in deletePos)
                    folder.ChangeType[i] = null;
                return;
            }

            FolderCompareObject f = null;

            for (int i = 0; i < currentPaths.Length; i++)
            {
                if (folder.ChangeType[i] == MetaChangeType.Delete)
                {
                    f = folder.Parent.GetRenamedFolder(folder.Name, folder.CreationTime[i], i);

                    if (f != null)
                    {
                        int counter = 0;

                        for (int j = 0; j < f.ChangeType.Length; j++)
                        {
                            if (f.ChangeType[j].HasValue && f.ChangeType[j] == MetaChangeType.New)
                                counter++;
                        }

                        if (counter != 1)
                        {
                            folder.ChangeType[i] = null;                         
                            return;
                        }

                        MergeRenamedFolder(folder, f, i);
                    }
                }
            }
        }
}}}


== Extending CompareAndSync ==


Tree Visitor Pattern:
http://groovy.codehaus.org/Visitor+Pattern
http://nice.sourceforge.net/visitor.html
http://www.surfscranton.com/architecture/VisitorPattern.htm
http://etymon.blogspot.com/2006/04/visitor-pattern-and-trees-considered.html